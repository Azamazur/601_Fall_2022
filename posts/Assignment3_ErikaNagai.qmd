---
title: "Homework3 Erika Nagai"
author: "Erika Nagai"
description: "Introduction to Visualization"
date: "11/30/2022"
format:
  html:
    toc: true
    code-copy: true
    code-tools: true
categories:
  - hw2
  - hw3
  - movie
  - gender
  - bechdel test
  - Erika Nagai
editor: 
  markdown: 
    wrap: 72
---

## Challenge Overview

**Data Analytics to understand how well women are represented in
movies.**

Is female representation in movies improving? - Are movies with good
female representation successful in terms of popularity and profit? -
Are women better represented in female-directed movies?

```{r}
# install libraries

library(tidyverse)
library(ggplot2)
library(stringr)
library(tidyr)
library(dplyr)
library(summarytools)
library(plyr)
library(lubridate)
library(ggridges)
```

## Read in data

For this analysis, I used the following different datasets.

(1) **movies_metadata.csv** : General information about movies released
    since 1880 , Obtained from Kaggle "The Movie
    Dataset"(<https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset?resource=download&select=movies_metadata.csv>),
    which was created from The Movie Database
    (<https://www.themoviedb.org/>) and MovieLens
    (<https://movielens.org/>).\

(2) **bechdel test** : Obtained by using bechdel test API
    <https://bechdeltest.com/api/v1/doc> This data documents if movies
    pass bechdel test, one of the most famous tests used for female
    representation in forms of art.

(3) **credit.csv** : Information of casts and crews of movies released
    since 1880,
    Dataset"(<https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset?resource=download&select=movies_metadata.csv>),
    which was created from The Movie Database
    (<https://www.themoviedb.org/>) and MovieLens
    (<https://movielens.org/>).

```{r}

#(1) movies_metadata.csv obtained from Kaggle
movie = read_csv("_data/movies_metadata.csv")
movie
```

```{r}

#(2) bechdel test obtained by using bechdel API

library(rjson)
library(jsonlite)

#json_file <- "http://bechdeltest.com/api/v1/getAllMovies"
#bechdel <- read_json(path = json_file, simplifyVector = TRUE)
#bechdel$titleId <- paste("tt",bechdel$imdbid, sep = "")

#write.csv(bechdel, file = "_data/bechdel.csv")
bechdel <- read_csv("_data/bechdel.csv")
bechdel

#imdbid and titleId are technically duplicated because titleId is tt+imdbid. movie_clean1 dataframe has IDs in the same format as titleId of bechdel df so I deleted imdbid column.
bechdel <- bechdel %>% select(-c(imdbid,...1))
colnames(bechdel) <- c("year", "title", "bechdel_rating", "id", "imdb_id")
bechdel

# I added a column bechdel_pass where 1 means the movie passes bechdel test and 0 means otherwise.
bechdel <- bechdel %>% mutate(
  bechdel_pass = case_when(
    bechdel_rating == 3 ~ 1,
    TRUE ~ 0
  )
)

```

```{r}
(3)
# Read in directors 

#R.utils::gunzip("~/DACSS/601_My_Project/Female_rep_movies/title.crew.tsv.gz")
#credits <- read.delim(file = "~/DACSS/601_My_Project/Female_rep_movies/title.crew.tsv", sep = "\t")

credit <- read_csv("_data/movie_credits.csv", na="NA")
```

## Describe data

### (1) TMDb

This movie dataset was generated by Movielens, a (non-profit) movie
review website (<https://movielens.org/>), and was obtained from the
following Kaggle link.
(<https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset?resource=download&select=movies_metadata.csv>)

The movie dataset is contains 45466 movies with a released date between
December 9th 1874 and December 16th 2020.

The data includes the information of genres, revenue, runtime,
languages, status (released/in production etc...).

```{r}


print(summarytools::dfSummary(movie),
      varnumbers = FALSE,
      plain.ascii  = FALSE,
      style        = "grid",
      graph.magnif = 0.80,
      valid.col    = FALSE,
      method = 'render',
      table.classes = 'table-condensed')
```

### (2) Bechdel test

`bechdel` dataset documents the bechdel test rating of 9630 movies
released between 1874 and 2022.

It has 9630 observations (movies) and 5 columns, which are released
year, title of movies, bechdel rating, and id. id that starts with "tt"
followed by 7 digits seems to work as a foreign key when joining this
data with `movie` dataset.

According to "Merriam-Webster", Bechdel test is "a set of criteria used
as a test to evaluate a work of fiction (such as a film) on the basis of
its inclusion and representation of female characters"
(<https://www.merriam-webster.com/dictionary/Bechdel%20Test>)

A movie passes bechdel test if

1\) At least two women are featured

2\) These women talk to each other

3\) They discuss something other than a man

**bechdel test rating is registered in a following manner.**

0 \~ No two female characters

1 \~ Two female characters but don't talk each other

2 \~ Two female characters talk each other about a man(men)

3 \~ Passes bechdel test: Two female characters talk each other about
other than a man (men)

```{r}
print(summarytools::dfSummary(bechdel),
      varnumbers = FALSE,
      plain.ascii  = FALSE,
      style        = "grid",
      graph.magnif = 0.80,
      valid.col    = FALSE,
      method = 'render',
      table.classes = 'table-condensed')
```

### (3) Credit data

This data documents the information of casts(actors, voice actors) and
crews (director, producer, etc) for each movie, which can identified by
id. The values in the column `cast` and `crew` are in json format.

```{r}
glimpse(credit)
```

## Tidy data

### (1) TMDb data

This dataset has several rows with NA values. Many are missing
`belong_to_collection`, which may make sense because most movies don't
belong to any collection.

Missing the below values might affect data analysis:\
`release_date` : because I want to analyze the trend over time\
`imdb_id`: because I will use this ID to join other datasets.

For now, I don't delete or replace NA values, however it is important to
note that there are several missing values.

```{r}
movie %>% select(everything()) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  t()
```

First of all, I deleted several columns, which seem to unnecessary or
have too many missing values.\
- `adult`: This information doesn't add any significant meaning as
almost all of observations have FALSE value for this column\
- `homepage`: URL of homepage. Unnecessary for this analysis\
- `belong_to_collection`: Has 40000+ missing values - poster_path\
- `video`: This information doesn't add any significant meaning as
almost all of observations have FALSE value for this column\

Then, I changed the order of the columns. Each row represents a movie so
the movie title should be the first column.

```{r}
movie <- movie %>% select(-c("adult", "homepage", "belongs_to_collection", "poster_path", "video"))

col_order <- c("title", "original_title", "tagline", "imdb_id", "id", "overview", "production_companies", "production_countries", "status", "release_date", "runtime", "revenue", "budget", "original_language", "spoken_languages", "popularity", "vote_average", "vote_count", "genres")
movie <- movie[, col_order]

colnames(movie)[5] <- "movielens_id"

colnames(movie)

```

The values in some certain columns such as "genres",
"production_companies", "production_countries","spoken_languages" are in
a list format for example:

> " \[{'id': XXXX, 'content(name/genre/title)': XXX}, {'id': XXXX,
> 'content(name/genre/title): XXX}\] "

These columns include `[]` `{}` and `'` in their values so I made a
function `remove_simbols` that removes these unnecessary symbols.

```{r}
movie %>% select(c("genres", "production_companies", "production_countries", "spoken_languages"))

remove_symbols <- function(x) {
  removed_x <- str_remove_all(x, "\\{|\\}|\\[|\\}|\\]|'|,|id|name|:| ")
  return(removed_x)
}
```

#### (1). Tidying `Genres`

Each movie contains information on one or more (up to 8) genres in a
single column. To organize the information, the multiple genres
contained in `genre` are split by "\]," so that each genre is contained
in eight new columns, genre1-genre8. Then, I removed unnecessary simbols
such as ,.

```{r}

# Separating the `genre` by "},"
movie <- movie %>% 
  separate(genres, c("genre1", "genre2", "genre3", "genre4", "genre5", "genre6", "genre7", "genre8"), "\\},", remove = FALSE)

# Remove unnecessary symbols from each columns

movie$genre1 <- remove_symbols(movie$genre1)
movie$genre2 <- remove_symbols(movie$genre2)
movie$genre3 <- remove_symbols(movie$genre3)
movie$genre4 <- remove_symbols(movie$genre4)
movie$genre5 <- remove_symbols(movie$genre5)
movie$genre6 <- remove_symbols(movie$genre6)
movie$genre7 <- remove_symbols(movie$genre7)
movie$genre8 <- remove_symbols(movie$genre8)

movie %>% 
  select(matches("[1-9]"))

```

I managed to separate the genre information above. Now all values in
genre1-genre8 has a value in the format of "number name of genre"
(example: 35Comedy)

However, there are 2,445 observations whose genre value doesn't fit the
above format. Most of them don't have any genre assigned so their
`genre1` values are empty or blank, which means they don't have any
genre assigned to them.

```{r}
movie %>% filter(!str_detect(genre1, "^[0-9]")) %>% select(starts_with("genre"))
```

However, looking at them closely, there are three observations whose
`genre` value that is NOT blank but have strange strings.

The values in these observations such as "Carousel Production" and
"Aniplex" don't look like a name of genres but that of production
studios. Also their `original_title` values don't look like a title of
movies but information of languages. It seems like these observations
were not correctly read in because their values in other columns look
weird.

Since these observations are not reliable, I decided to delete them from
this dataset.

```{r}
movie %>% filter(!str_detect(genre1, "^[0-9]") &!str_detect(genre1, "^[ \t\n]*$")) %>% #^[ \t\n]*$ is a regular expression for blank.
  select(c(original_title, title, production_countries, genre1:genre8))

movie_clean1 <- movie %>% filter(!str_detect(genre1, "^[A-Z]"))
```

Genre information is more organized but is still not easy to be
analyzed. Thus, I decided to make dummy variables of each genre.

For example, if movie A is categorized as "comedy" and "adventure", the
line of movie A should have 1 in "comedy" column and "adventure"
respectively and 0 in columns of other genres.

```{r}

#https://community.rstudio.com/t/creating-dummy-columns-based-on-multiple-columns/58145/3
movie_clean1 <- movie_clean1 %>% 
  pivot_longer(cols = matches("genre[1-9]")) %>%
  add_column(count = 1) %>%
  arrange(value) %>%
  filter(str_detect(value, "^[0-9]")) %>%
  mutate(value1 = str_replace_all(value, "[0-9]+", "")) %>%
  select(-c(value, name)) %>%
  arrange(title) %>%
  pivot_wider(
    names_from = value1, 
    values_from = count, 
    values_fill = list(count=0),
    values_fn = list(count = mean)) %>%
  arrange(title)

# I also deleted genre "TVMovie" and "Foreign" because they're more format or origin country information rather than genre.
movie_clean1 <- movie_clean1 %>% select(-c("TVMovie","Foreign"))
movie_clean1[,20:37]
```

#### (2). Tyding `Production_countries`

The values in `production_countries` are written in the following way.
\>\[{'iso_3166_1': 'abbreviation of country','name': 'full country
name'}\]

When there are more than one country in the value, I took the first
country in account for this analysis.

```{r}
movie_clean1$production_countries <- remove_symbols(movie_clean1$production_countries)
movie_clean1$production_countries <- str_extract(movie_clean1$production_countries,"(?<=_1)\\w{2}")

movie_clean1 %>% select(production_countries)
```

#### (3). Tyding `production_companies` & `spoken_languages`

The values in both of `production_companies` and `spoken_languages` are
in the following format. \> \[{'name': 'XXXX', 'id': ---}\] \>
\[{'iso_639_1':'XXXX', 'name':"----}\]

I only need the information that is written as XXXX in this format.

```{r}

movie_clean1$production_companies <-str_remove_all(movie_clean1$production_companies, "'id': [0-9]*|'name':|\\[|\\]|'|\\{|,") %>%
  str_replace_all("\\},", ",") %>%
  str_replace_all(" \\} ", ",")%>%
  str_remove(" \\}")

movie_clean1$spoken_languages <-str_remove_all(movie_clean1$spoken_languages, "'iso_639_1':|'name': '\\w+'|\\[|\\]|'|\\{|,") %>%
  str_replace_all(" \\} ", ",") %>%
  str_remove_all(" \\}")

movie_clean1 %>% select(production_companies, spoken_languages)


```

Now, the dataset is cleaner. Look at the summary again.

```{r}
print(summarytools::dfSummary(movie_clean1),
      varnumbers = FALSE,
      plain.ascii  = FALSE,
      style        = "grid",
      graph.magnif = 0.80,
      valid.col    = FALSE,
      method = 'render',
      table.classes = 'table-condensed')

```

###(3) Credit Data The values in the columns `cast` and `crew` are in
json-like format. I made `cast_data` and `crew_data` dataframes and
converted the values that are in {} in `credit` dataframe into each row
so that every row means one cast/crew.

#### Making crew list

```{r}
#
parse_crew <- function(crew_text) {
  text <- 
    sub("\\£\\$\\£", "",    #drop the first one
        gsub("\'|\"|\\[|\\]|\\{|\\}|,", "",
             gsub("\'credit_id\':|\'department\':|\'gender\':|\'id\':|\'job\':|\'name\':|\'profile_path\':", 
                  "£$£", 
                  crew_text)
        )
    )
  
  data <- data.frame(matrix(
    trimws(unlist(
        strsplit(text, "\\£\\$\\£")
        )), 
    ncol = 7, byrow = TRUE), stringsAsFactors = FALSE)
  
  names(data) <- c("credit_id", "department", "gender", "id", "job", "name", "profile_path")
  
  return(data %>% select(credit_id, gender, id, name, department, job))
}

num_batches <- 50
batch_interval <- ceiling(nrow(credit) / num_batches)
batch_brackets <- 0:num_batches * batch_interval
batch_brackets[num_batches+1] <- nrow(credit)
batch_brackets[1] <- 1
crew_data <- data.frame()

for(b_i in 1:num_batches){
  
  batch_data <- data.frame()
  for(b2_i in batch_brackets[b_i]:(batch_brackets[b_i+1]-1)){
    #print(b2_i)
    this_crew <- parse_crew(credit$crew[b2_i])
    if(nrow(this_crew) > 0){
      this_crew$movie_id <- as.character(credit$id[b2_i])
      batch_data <- rbind(batch_data, this_crew)
    }
  }
  crew_data <- rbind(crew_data, batch_data)
}

crew_data %>% 
  filter(job == "Director") %>%
  group_by(gender) %>%
  dplyr::summarize(number = n())

crew_data <- crew_data %>%
  mutate(
    gender = case_when(
    gender == 0 ~ "unknown",
    gender == 1 ~ "female",
    gender == 2 ~ "male",
    TRUE ~ "NA"
  ))
```

I created a new data frame, `female_director` that documents if a movie
was directed by a women (women). The value in the column
`female_director` is 1 if the movie is directed by at least one woman.

```{r}
female_director <- crew_data %>% 
  filter(job == "Director") %>%
  group_by(id) %>%
  dplyr::summarize(
    n_director = n(),
    n_female_director = sum(gender=="female")
  ) %>%
  mutate(
    female_director = case_when(
      n_female_director == 0 ~ 0,
      TRUE ~ 1
    )
  )
female_director$id <- as.double(female_director$id)
female_director
  
```

#### Making cast list

```{r}
#function to remove symboles
parse_cast <- function(cast_text) {
  text <- 
    sub("\\£\\$\\£", "",    #drop the first one
        gsub("\'|\"|\\[|\\]|\\{|\\}|,", "",
             gsub("\'cast_id\':|\'character\':|\'credit_id\':|\'gender\':|\'id\':|\'name\':|\'order\':|\'profile_path\':", 
                  "£$£", 
                  cast_text)
        )
    )
  
  data <- data.frame(matrix(
    trimws(unlist(
        strsplit(text, "\\£\\$\\£")
        )), 
    ncol = 8, byrow = TRUE), stringsAsFactors = FALSE)
  
  names(data) <- c("cast_id", "character", "credit_id", "gender", "id", "name", "order", "profile_path")
  data$order <- as.numeric(data$order)
  
  return(data %>% select(cast_id, character, gender, id, name, order))
}


num_batches <- 50
batch_interval <- ceiling(nrow(credit) / num_batches)
batch_brackets <- 0:num_batches * batch_interval
batch_brackets[num_batches+1] <- nrow(credit)
batch_brackets[1] <- 1


cast_data <- data.frame()
for(b_i in 1:num_batches){
  
  batch_data <- data.frame()
  for(b2_i in batch_brackets[b_i]:(batch_brackets[b_i+1]-1)){
    #print(b2_i)
    this_cast <- parse_cast(credit$cast[b2_i])
    if(nrow(this_cast) > 0){
      this_cast$movie_id <- as.character(credit$id[b2_i])
      batch_data <- rbind(batch_data, this_cast)
    }
  }
  cast_data <- rbind(cast_data, batch_data)
  
}

cast_data %>%
  mutate(
    gender = case_when(
    gender == 0 ~ "unknown",
    gender == 1 ~ "female",
    gender == 2 ~ "male",
    TRUE ~ "NA"
  ))


cast_data
```

## Exploratory Analysis - Basic movie trends -

**1. The number of released movies registered in movielens**
(https://movielens.org/)

```{r}
movie_clean1 %>%
  group_by(year = lubridate::year(release_date)) %>%
  dplyr::summarize(total_n = n()) %>%
  ggplot(aes(x=year, y=total_n)) + 
  geom_line() +
  labs(y = "Total number of movies", 
       title = "The total number of movies registered at TMDb",
       subtitle = "The number of registered movies each year is increasing from around 1920",
       caption = "Source https://movielens.org/")

```

## Female representation in movies -

**Are more women directing movies?**

The short answer is not really. As far as we can see from the data, the
number of movies directed by woman (women) is not increasing. However,
we should keep in mind that the `credit.csv` doesn't cover all the
movies released or registered on Movielens/TMDb so we may be missing
many movies that women directed.

```{r}
# join "movie" and "female_director"

inner_join(female_director, movie, copy = TRUE, by = c("id" = "movielens_id")) %>%
  group_by(year = lubridate::year(release_date), female_director) %>%
  dplyr::summarize(n_total = n()) %>%
  ggplot(aes(x=year, y= n_total, fill = as.character(female_director))) + geom_bar(stat = "identity") +
  scale_fill_manual(values = c("grey", "orange"),
                    labels=c("only male director(s)", "at least one female director"))



```

**Are there more films where female characters appear?**

We can refer to if the movie passes the Bechdel test. The number of
movies that pass the Bechdel test increases over time, especially after
around 1980 as the total number of released movies increased.

```{r}


inner_join(movie_clean1, bechdel, copy = TRUE) %>%
  filter(lubridate::year(release_date) > 1920) %>%
  group_by(year = lubridate::year(release_date), bechdel_rating) %>%
  dplyr::summarize(n_total = n()) %>%
  ggplot(aes(x=year, y= n_total, fill = as.character(bechdel_rating))) + geom_area(stat = "identity") +
  scale_fill_manual(values = c("gray0", "gray40", "gray80", "orange"),
                    labels=c("No two female characters", "Two female characters", "That talk each other", "Other than a man (Passes Bechdel Test)")) +
  labs(x= "year", y = "Total number of movies", title = "The number of movies that pass/don't pass Bechdelt test")
  

```

The percentage of films that pass the bechdel test has been gradually
increasing since around 1975, and currently nearly 70% of films pass the
bechdel test. However, there was a year around 1950 when 70% of films
passed the bechdel test, and it cannot be said that the percentage of
films passing the bechdel test has increased compared to 70 years ago.

```{r}
movie_bechdel_join <- inner_join(movie_clean1, bechdel, copy = TRUE) 

movie_bechdel_join %>%
  filter(lubridate::year(release_date) > 1920) %>%
  group_by(year = lubridate::year(release_date), bechdel_rating) %>%
  dplyr::summarize(n_total = n()) %>%
  ggplot(aes(x=year, y= n_total, fill = as.character(bechdel_rating))) + geom_area(stat = "identity", position="fill") +
  scale_fill_manual(values = c("gray0", "gray40", "gray80", "orange"),
                    labels=c("No two female characters", "Two female characters", "That talk each other", "Other than a man (Passes Bechdel Test)")) +
  labs(x="year", y="percentage", title = "% of movies that pass/don't pass Bechdel Test")
```

**What category represents women better?**

I focused on the movies released between 1970 and 2022 because there is
a small number of movies released before 1970 (25- movies a year) and
it's better to focus on the era where more movies were released to
observe the trend.

The degree to which women are portrayed in a film's story varies widely
from genre to genre.

For example, many movies in Comedy, Animation, Drama, Family, Fantasy,
Romance, and Music pass the Bechdel test, while Action, Adventure,
Crime, History, War, and Western The percentage of films that pass the
Bechdel test is about 50% or less.

```{r}
movie_bechdel_join %>%
  colnames()

movie_bechdel_join %>%
  pivot_longer(cols = c(War:Music),names_to = "genre_name", values_drop_na = TRUE) %>%
  filter(value == 1) %>%
  filter(lubridate::year(release_date) > 1970) %>%
  group_by(year = lubridate::year(release_date), bechdel_rating, genre_name) %>%
  dplyr::summarize(n_total = n()) %>%
  ggplot(aes(x=year, y= n_total, fill = as.character(bechdel_rating))) + 
  geom_bar(stat = "identity", position = "fill") +
  facet_wrap(~genre_name, ncol = 3)+
  scale_fill_manual(values = c("gray0", "gray40", "gray80", "orange"),
                    labels=c("No two female characters", "Two female characters", "That talk each other", "Other than a man (Passes Bechdel Test)")) +
  labs(x = "year", y = "proportion", title = "Proportion of movies that pass / don't pass Bechdel test by categories")
  
  

```

**Do movies with good female representation succeed in getting more
popularity on online review site?**

There seems to be no relationship between whether a film passes the
bechdel test and its reputation (voting average).

```{r}
movie_bechdel_join %>%
  filter(lubridate::year(release_date) > 1970) %>%
  ggplot(aes(x=as.character(bechdel_rating), y=vote_average)) + geom_boxplot()


```

```{r}
